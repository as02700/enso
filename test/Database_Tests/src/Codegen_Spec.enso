from Base import all
from Database import all
from Table import No_Such_Column_Error, Order_Rule
import Database.Connection.Connection
import Database.Data.Dialect
import Test

spec =
    test_connection =
        table1 = ["T1", ["A", "B", "C"]]
        table2 = ["T2", ["D", "E", "F"]]
        table3 = ["T3", ["A", "E", "F"]]
        tables = Map.from_vector [table1, table2, table3]
        Connection.make_fake_connection Dialect.sqlite tables
    t1 = test_connection.access_table "T1"
    Test.group "JSON serialization" <|
        Test.specify "should serialize Tables and Columns to their SQL representation" <|
            q1 = t1.where (t1.at "B" == 42) . to_json
            part1 = Json.from_pairs [["sql_code", "SELECT (T1.A) AS A, (T1.B) AS B, (T1.C) AS C FROM T1 AS T1 WHERE (T1.B = "]]
            part2 = Json.from_pairs [["sql_interpolation", 42]]
            part3 = Json.from_pairs [["sql_code", ")"]]
            expected = Json.from_pairs [["query", Json.Array [part1, part2, part3]]]
            q1.should_equal expected

            q2 = t1.at "A" . to_json
            q2.should_equal (Json.from_pairs [["query", Json.Array [Json.from_pairs [["sql_code", "SELECT (T1.A) AS A FROM T1 AS T1"]]]]])

    Test.group "Basic Select" <|
        Test.specify "should select columns from a table" <|
            t1.to_sql.prepare . should_equal ["SELECT (T1.A) AS A, (T1.B) AS B, (T1.C) AS C FROM T1 AS T1", []]
            t2 = t1.select ["C", "B", "undefined"]
            t2.to_sql.prepare . should_equal ["SELECT (T1.C) AS C, (T1.B) AS B FROM T1 AS T1", []]

            foo = t2.at "A" . rename "FOO"
            foo.to_sql.prepare . should_equal ["SELECT (T1.A) AS FOO FROM T1 AS T1", []]

            t3 = t2.set "bar" foo
            t3.to_sql.prepare . should_equal ["SELECT (T1.A) AS bar FROM T1 AS T1", []]

    Test.group "Building Expressions" <|
        Test.specify "should allow building expressions from columns and constants" <|
            0 # TODO

    Test.group "Masking Tables" <|
        Test.specify "should allow filtering table rows based on a boolean expression" <|
            0 # TODO
        Test.specify "should treat NA values in the mask as false" <|
            0 # TODO

    Test.group "Masking Columns" <|
        Test.specify "should allow selecting column rows based on a boolean expression" <|
            0 # TODO

    Test.group "Joining Tables" <|
        t2 = test_connection.access_table "T2"
        t3 = test_connection.access_table "T3"
        Test.specify "should allow joining tables index-on-index" <|
            r_1 = t1.set_index 'A' . join (t2.set_index 'A')
            # TODO

        Test.specify "should allow joining tables column-on-index" <|
            r_1 = t1.join (t2.set_index 'A') on='B'
            # TODO

        Test.specify "should append suffixes to disambiguate column names" <|
            r1 = t1.join (t3.set_index 'A') on='E'
            # TODO

    Test.group "Filling Missing Values" <|
        Test.specify "should allow to replace missing values in a column with a constant" <|
            # TODO

        Test.specify "should allow to replace missing values in a column with a column" <|
            # TODO do we want to support this?

    Test.group "Counting Values" <|
        Test.specify "should count missing and non-missing values" <|
            col = t1.at "A"
            # TODO counting nulls in SQL
#            col.length
#            col.count
#            col.count_missing

    Test.group "Dropping Missing Values" <|
        Test.specify "should drop missing rows in a Column" <|
            col = t1.at "A" . drop_missing
            # TODO

        Test.specify "should drop rows that contain at least one missing column in a Table" <|
            t1.drop_missing_rows
            # TODO

    Test.group "Aggregation" <|
        agg = t1.group by='A'

        Test.specify "should allow counting group sizes" <|
            agg.count.to_vector.should_equal [3, 2, 1, 1]

        Test.specify "should allow aggregating columns with basic arithmetic aggregators" <|
            agg.at 'B' . mean # TODO
            agg.at 'B' . min

    Test.group "Sorting" <|
        Test.specify "should allow sorting by a single column name" <|
            r1 = t1.sort by="A" . at "B" # TODO
            r_3 = t1.sort by="B" missing_last=False order=Sort_Order.Descending . at "A"

        Test.specify 'should allow sorting by multiple column names' <|
            r_1 = t1.sort by=['A', 'B'] # TODO

        Test.specify 'should allow sorting by expressions' <|
            sum = t1.at 'A' + t1.at 'B'
            r_1 = t1.sort by=sum . at "C" # TODO

        Test.specify 'should allow sorting with specific by-column rules' <|
            r_1 = t1.sort by=['A', (Order_Rule 'B' order=Sort_Order.Descending)] # TODO

        Test.specify 'should return dataflow error when passed a non-existent column' <|
            r = t1.sort by='foobar'
            r.should_fail_with No_Such_Column_Error
