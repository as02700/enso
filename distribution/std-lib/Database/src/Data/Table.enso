## Represents a column-oriented table data structure backed by a database.
type Table
    # type Table (connection : Connection)
    #            (internal_columns : Vector (Pair Text IR.Expression))
    #            (context : IR.Context)
    type Table connection internal_columns context

    ## Returns a text containing an ASCII-art table displaying this data.

       Arguments:
         - show_rows: the number of initial rows that should be displayed.
         - format_terminal: whether ANSI-terminal formatting should be used
    display : Integer -> Boolean -> Text
    display show_rows=10 format_terminal=False =
        Error.throw "TODO"

    ## Prints an ASCII-art table with this data to the standard output.

       Arguments:
         - show_rows: the number of initial rows that should be displayed.
    print show_rows=10 =
        IO.println (this.display show_rows format_terminal=True)
        IO.println ''

    ## Converts this table to a JSON structure.
    to_json : Json
    to_json =
        col_jsons = this.columns.map .to_json
        cols_json = Json.Array col_jsons
        fields = Map.singleton "columns" cols_json
        Json.Object fields

    ## Returns the column with the given name.
    at : Text -> Column | Nothing
    at name = case this.internal_columns.find (p -> p.first == name) of
        Nothing -> Nothing
        p -> this.make_column p

    ## Selects only the rows of this table that correspond to `True` values in
       `filter`.
       This is useful for filtering the rows by given predicate.
       > Example
         Select only the rows of `my_table` where the `"Status"` column has the
         value `"Valid"`
             my_table.where (my_table.at "Status" == "Valid")
    where : Column -> Table
    where filter =
        case filter.context == this.context of
            False ->
                # TODO [RW] more descriptive errors
                Error.throw "Filtering over a column with differing context."
            True ->
                new_filters = this.context.where_filters + [filter.expression]
                new_ctx = this.context.set_where_filters new_filters
                this.updated_context new_ctx

    ## Sets the column value at the given name. If a column with the given name
       already exists, it will be replaced. Otherwise a new column is added.
    set : Text -> Column -> Table
    set name column =
#        Table (this.java_table.addOrReplaceColumn [column.rename name . java_column])
        Error.throw "TODO"

    ## Returns the vector of columns contained in this table.
    columns : Vector Column
    columns = this.internal_columns . map this.make_column

    ## Sets the index of this table, using the column with the provided name.
    set_index : Text | Vector Text -> Table
    set_index index =
        ind = case index of
            Vector -> index
            _ -> [index]
        new_context = this.context.set_index ind
        this.updated_context new_context

    ## Selects a subset of columns from this table by name.
    select : Vector Text -> Table
    select columns =
        find_col = (name -> this.internal_columns.find (p -> p.name == name))
        selected_cols = columns.map find_col . filter (!= Nothing)
        this.updated_columns selected_cols

    ## Efficiently joins two tables based on either the index or a key column.

       The resulting table contains rows of `this` extended with rows of
       `other` with matching indexes. If the index in `other` is not unique,
       the corresponding rows of `this` will be duplicated in the result.

       Arguments:
         - other: the table being the right operand of this join operation.
         - on: the column of `this` that should be used as the join key. If
               this argument is not provided, the index of `this` will be used.
         - drop_unmatched: whether the rows of `this` without corresponding
                           matches in `other` should be dropped from the result.
         - left_suffix: a suffix that should be added to the columns of `this`
                        when there's a name conflict with a column of `other`.
         - right_suffix: a suffix that should be added to the columns of `other`
                         when there's a name conflict with a column of `this`.
    join : Table -> Text | Nothing -> Boolean -> Text -> Text -> Table
    join other on=Nothing drop_unmatched=False left_suffix='_left' right_suffix='_right' =
        Error.throw "TODO"

    ## Returns a new Table without rows that contained missing values in any of
       the columns.
    drop_missing_rows : Table
    drop_missing_rows =
#        cols = this.columns
#        case cols.not_empty of
#            True ->
#                any_missing_mask = cols.map is_missing . reduce (||)
#                non_missing_mask = any_missing_mask.not
#                this.where non_missing_mask
#            False -> this
        Error.throw "TODO"

    ## Returns a new Table without columns that contained any missing values.
    drop_missing_columns : Table
    drop_missing_columns =
        Error.throw "TODO"

    ## Returns the amount of rows in this table.
    nrows : Integer
    nrows = Error.throw "TODO"

    to_dataframe : (Integer | Nothing) -> Table.Table
    to_dataframe limit=Nothing =
        Error.throw "TODO"

    to_sql : Text
    to_sql =
        col_expressions = this.internal_columns . map .first
        IR.generate_sql this.connection.dialect col_expressions this.context

    explain_query_plan : Text
    explain_query_plan =
        Error.throw "TODO"

    ## Returns a Table describing this table's contents.

       The table lists all columns, counts of non-null items and storage types
       of each column.
    info : Table
    info =
        cols = this.columns
        here.new [["Column", cols.map .name], ["Items Count", cols.map .count], ["Storage Type", cols.map .storage_type]]

    ## PRIVATE
    make_column : Pair Text IR.Expression -> Column
    make_column pair =
        Column pair.first this.connection pair.second this.context

    ## PRIVATE
    updated_columns columns = Table this.connection columns this.context

    ## PRIVATE
    updated_context ctx = Table this.connection this.internal_columns ctx


make_table : Connection -> Text -> Vector Text -> Table
make_table connection table_name column_names =
    ctx = IR.make_ctx_from table_name
    column_names.map (name -> Column connection (Column table_name name) ctx)
