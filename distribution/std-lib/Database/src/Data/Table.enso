from Base import all
from Database.Data.Column as Column_Module import all
from Database.Data.Helpers import all
import Database.Data.Internal.IR

## Represents a column-oriented table data structure backed by a database.
type Table
    # type Table (connection : Connection)
    #            (internal_columns : Vector (Pair Text IR.Expression))
    #            (context : IR.Context)
    type Table connection internal_columns context

    ## Returns a text containing an ASCII-art table displaying this data.

       Arguments:
         - show_rows: the number of initial rows that should be displayed.
         - format_terminal: whether ANSI-terminal formatting should be used
    display : Integer -> Boolean -> Text
    display show_rows=10 format_terminal=False =
        this.to_dataframe.display show_rows format_terminal

    ## Prints an ASCII-art table with this data to the standard output.

       Arguments:
         - show_rows: the number of initial rows that should be displayed.
    print show_rows=10 =
        IO.println (this.display show_rows format_terminal=True)
        IO.println ''

    ## Converts this table to a JSON structure.
    to_json : Json
    to_json =
        col_jsons = this.columns.map .to_json
        cols_json = Json.Array col_jsons
        fields = Map.singleton "columns" cols_json
        Json.Object fields

    ## Returns the column with the given name.
    at : Text -> Column | Nothing
    at name = case this.internal_columns.find (p -> p.first == name) of
        Nothing -> Nothing
        p -> this.make_column p

    ## Selects only the rows of this table that correspond to `True` values in
       `filter`.
       This is useful for filtering the rows by given predicate.
       > Example
         Select only the rows of `my_table` where the `"Status"` column has the
         value `"Valid"`
             my_table.where (my_table.at "Status" == "Valid")
    where : Column -> Table
    where filter =
        case Helpers.check_integrity this filter of
            False ->
                # TODO [RW] more descriptive errors
                Error.throw "Filtering over a column with differing context."
            True ->
                new_filters = this.context.where_filters + [filter.expression]
                new_ctx = this.context.set_where_filters new_filters
                this.updated_context new_ctx

    ## Sets the column value at the given name. If a column with the given name
       already exists, it will be replaced. Otherwise a new column is added.
    set : Text -> Column -> Table
    set name column =
        new_col = Pair name column.expression
        replace = this.internal_columns.exists (c -> c.name == name)
        case replace of
            True ->
                new_cols = this.internal_columns.map (c -> if c.name == name then new_col else c)
                this.updated_columns new_cols
            False ->
                this.updated_columns (this.internal_columns + [new_col])

    ## Returns the vector of columns contained in this table.
    columns : Vector Column
    columns = this.internal_columns . map this.make_column

    ## Sets the index of this table, using the column with the provided name.
    set_index : Text | Vector Text -> Table
    set_index index =
        new_ctx = this.context.set_index (Helpers.unify_vector_singleton index)
        this.updated_context new_ctx

    order : Nothing | Column | Vector Column -> Table
    order by=Nothing = case by of
        Nothing ->
            if this.context.meta_index.is_empty then Error.throw "Trying to order by an empty index." else
                new_ctx = this.context.set_orders this.context.meta_index
                this.updated_context new_ctx
        _ ->
            cols = Helpers.unify_vector_singleton by
            case cols.forall (Helpers.check_integrity this) of
                True ->
                    new_ctx = this.context.set_orders (cols.map .expression)
                    this.updated_context new_ctx
                False ->
                    Error.throw "The columns to be ordered by come from a different context."

    ## Selects a subset of columns from this table by name.
    select : Vector Text -> Table
    select columns =
        find_col = (name -> this.internal_columns.find (p -> p.name == name))
        selected_cols = columns.map find_col . filter (!= Nothing)
        this.updated_columns selected_cols

    ## Efficiently joins two tables based on either the index or a key column.

       The resulting table contains rows of `this` extended with rows of
       `other` with matching indexes. If the index in `other` is not unique,
       the corresponding rows of `this` will be duplicated in the result.

       Arguments:
         - other: the table being the right operand of this join operation.
         - on: the column(s) of `this` that should be used as the join key. If
               this argument is not provided, the index of `this` will be used.
         - drop_unmatched: whether the rows of `this` without corresponding
                           matches in `other` should be dropped from the result.
         - left_suffix: a suffix that should be added to the columns of `this`
                        when there's a name conflict with a column of `other`.
         - right_suffix: a suffix that should be added to the columns of `other`
                         when there's a name conflict with a column of `this`.
    join : Table -> Vector Text | Text | Nothing -> Boolean -> Text -> Text -> Table
    join other on=Nothing drop_unmatched=False left_suffix='_left' right_suffix='_right' =
        kind = if drop_unmatched then IR.InnerJoin else IR.LeftJoin
        my_index : Vector Expression
        my_index = case on == Nothing of
            True -> this.context.meta_index
            False ->
                (Helpers.unify_vector_singleton on).map (name -> this.at name . expression)
        other_index = other.context.meta_index
        case my_index.length == other_index.length of
            False -> Error.throw "Cannot join with multi-indexes of different lengths."
            True ->
                # TODO [RW] we can easily avoid creating subqueries if there are no groups, orders or wheres, so it may be worth optimizing that here
                left_alias = "TLeft" # TODO [RW]
                right_alias = "TRight" # TODO [RW]
                new_index = [] # TODO [RW] should join preserve left index?
                # TODO [RW] renaming expressions!!!
                left_query = IR.SubQuery this.internal_columns this.context left_alias
                right_query = IR.SubQuery other.internal_columns other.context right_alias

                on_exprs = my_index.zip other_index (l -> r -> l == r)
                new_from = IR.Join left_query right_query on_exprs
                new_ctx = IR.Context new_from [] [] [] new_index

                # TODO [RW] renaming columns
                new_left_columns = this.internal_columns.map (p -> Pair p.first (IR.Column left_alias p.first))
                new_right_columns = other.internal_columns.map (p -> Pair p.first (IR.Column right_alias p.first))
                new_columns = new_left_columns + new_right_columns
                Table this.connection new_columns new_ctx


    ## Returns an aggregate table resulting from grouping the elements by the
       value of the specified column.

       If the `by` argument is not set, the index is used for grouping instead.

       > Example
         Creates a simple table and computes aggregation statistics:
            name = ['name', ["foo", "bar", "foo", "baz", "foo", "bar", "quux"]]
            price = ['price', [0.4, 3.5, Nothing, 6.7, Nothing, 97, Nothing]]
            quantity = ['quantity', [10, 20, 30, 40, 50, 60, 70]]
            t = Table.new [name, price, quantity]

            agg = t.group by='name'

            records_num = agg.count
            total_quantity = agg.at 'quantity' . sum
            mean_price = agg.at 'price' . mean

            Table.join [records_num, total_quantity, mean_price]
    group : Vector Text | Text | Nothing -> Aggregate_Table
    group by=Nothing =
        Error.throw "TODO"

    ## Returns a new Table without rows that contained missing values in any of
       the columns.
    drop_missing_rows : Table
    drop_missing_rows =
        filters = this.columns.map (c -> c.is_missing.not)
        new_ctx = this.context.set_where_filters (this.context.where_filters + filters)
        this.updated_context new_ctx

    ## Returns a new Table without columns that contained any missing values.
    drop_missing_columns : Table
    drop_missing_columns =

        Error.throw "TODO"

    ## Returns the amount of rows in this table.
    nrows : Integer
    nrows = Error.throw "TODO"

    to_dataframe : (Integer | Nothing) -> Table.Table
    to_dataframe limit=Nothing =
        Error.throw "TODO"

    to_sql : SQL.Statement
    to_sql =
        col_expressions = this.internal_columns . map .second
        query = IR.Select col_expressions this.context
        this.connection.dialect.generate_sql query

    explain_query_plan : Text
    explain_query_plan =
        this.connection.explain_query_plan this.to_sql

    ## Returns a Table describing this table's contents.

       The table lists all columns, counts of non-null items and storage types
       of each column.
    info : Table
    info =
        cols = this.columns
        here.new [["Column", cols.map .name], ["Items Count", cols.map .count], ["Storage Type", cols.map .storage_type]]

    ## PRIVATE
    make_column : Pair Text IR.Expression -> Column
    make_column pair =
        Column pair.first this.connection pair.second this.context

    ## PRIVATE
    updated_columns columns = Table this.connection columns this.context

    ## PRIVATE
    updated_context ctx = Table this.connection this.internal_columns ctx


## PRIVATE
make_table : Connection -> Text -> Vector Text -> Table
make_table connection table_name column_names =
    ctx = IR.make_ctx_from table_name
    cols = column_names.map (name -> Pair name (IR.Column table_name name))
    Table connection cols ctx
